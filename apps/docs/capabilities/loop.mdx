---
title: Loop Command
sidebarTitle: "Loop Command"
description: "Run Claude Code in autonomous loops for batch task completion"
---

# Loop Command

The `loop` command runs Claude Code in autonomous loops, spawning fresh agent sessions for each iteration. This approach, known as the "Ralph Wiggum pattern" (credited to Jeffrey Huntley, popularized by Matt Pocock), maintains context quality by avoiding long-running sessions that accumulate context fatigue.

## Overview

Instead of a single long-running agent session that degrades over time, the loop command:

1. **Spawns fresh sessions** - Each iteration starts with a clean context
2. **Uses preset prompts** - Built-in or custom prompts guide each iteration
3. **Tracks progress** - A progress file persists notes across sessions
4. **Detects completion** - Special markers signal when work is done or blocked

This pattern is ideal for batch operations like clearing task backlogs, improving test coverage, or fixing lint errors across a codebase.

## Basic Usage

Run 10 iterations with the default task-completion preset:

```bash
task-master loop -n 10
```

Run 5 iterations with the test-coverage preset:

```bash
task-master loop -n 5 --prompt test-coverage
```

Run iterations with a custom prompt file:

```bash
task-master loop -n 10 --prompt ./my-custom-prompt.md
```

Filter to specific task tag:

```bash
task-master loop -n 10 --tag backend
```

## How It Works

Each loop iteration:

1. Generates a prompt combining context header + preset content
2. Spawns `claude -p <prompt>` as a fresh subprocess
3. Captures output and checks for completion markers
4. Appends progress notes to the progress file
5. Sleeps before the next iteration (configurable)

The loop exits early when:
- An agent outputs `<loop-complete>REASON</loop-complete>` - all work done
- An agent outputs `<loop-blocked>REASON</loop-blocked>` - cannot proceed
- Maximum iterations reached

## Progress File

Each iteration's agent has access to a shared progress file (default: `.taskmaster/loop-progress.txt`) via the `@` file reference syntax. Agents append notes about what they completed, allowing subsequent iterations to build on previous work.

Example progress file content:

```
# Loop Progress - Started 2025-01-09 10:30:00
# Preset: test-coverage | Iterations: 10

[10:30:45] Iteration 1 (Task 5.2): Added unit tests for UserService
[10:35:22] Iteration 2 (Task 5.3): Added integration tests for auth flow
[10:40:18] Iteration 3: All pending test tasks complete
```

## CLI Options

| Option                   | Type   | Default                         | Description                                                                                                   |
| ------------------------ | ------ | ------------------------------- | ------------------------------------------------------------------------------------------------------------- |
| `-n, --iterations`       | number | `10`                            | Maximum number of iterations to run.                                                                          |
| `-p, --prompt`           | string | `default`                       | Preset name or path to a custom prompt file. Accepts: `default`, `test-coverage`, `linting`, `duplication`, `entropy`, or a file path like `./my-prompt.md`. |
| `--progress-file`        | string | `.taskmaster/loop-progress.txt` | Path to the progress log file where iteration notes are appended.                                             |
| `--sleep`                | number | `5`                             | Seconds to wait between iterations. Gives the system time to settle before spawning the next agent.          |
| `--on-complete`          | string | -                               | Shell command to run when all tasks complete (status becomes `all_complete`). Example: `--on-complete 'notify-send "Done!"'` |
| `-t, --tag`              | string | -                               | Filter to only work on tasks with this tag.                                                                   |
| `--status`               | string | `pending`                       | Filter to only work on tasks with this status.                                                                |
| `--project`              | string | -                               | Project root directory. Auto-detected if not provided.                                                        |
| `--json`                 | flag   | -                               | Output results as JSON instead of formatted text.                                                             |

### Option Details

**`--prompt` accepts two types of values:**
- **Preset names**: Use built-in presets like `default`, `test-coverage`, `linting`, `duplication`, or `entropy`
- **File paths**: Provide a path to a custom prompt file (e.g., `./my-custom-loop.md`)

**`--on-complete` runs only on success:**
The shell command only executes when `finalStatus` is `all_complete`, meaning an agent output the `<loop-complete>` marker. It does not run on `max_iterations`, `blocked`, or `error` outcomes.

## Built-in Presets

The loop command includes five built-in presets for common development workflows. Each preset guides agents to complete ONE focused task per iteration.

| Preset | Purpose | Completion Marker |
| ------ | ------- | ----------------- |
| `default` | Complete tasks from Task Master backlog | `ALL_TASKS_DONE` |
| `test-coverage` | Write meaningful tests for uncovered code | `COVERAGE_TARGET` |
| `linting` | Fix lint and type errors one by one | `ZERO_ERRORS` |
| `duplication` | Refactor duplicated code into shared utilities | `LOW_DUPLICATION` |
| `entropy` | Clean up code smells (long functions, deep nesting) | `LOW_ENTROPY` |

### default

The standard task completion workflow. Agents work through your Task Master backlog, completing one task per iteration.

```bash
task-master loop -n 10 --prompt default
```

**What it does:**
1. Runs `task-master next` to get the highest priority available task
2. Reads task details with `task-master show <id>`
3. Implements the task with the smallest possible change
4. Runs tests and type checks to verify quality
5. Marks the task complete with `task-master set-status --id=<id> --status=done`
6. Commits work with a descriptive message

**Completion criteria:** All pending tasks are complete.

### test-coverage

Improves test coverage by writing meaningful tests for user-facing behavior - not just chasing coverage numbers.

```bash
task-master loop -n 10 --prompt test-coverage
```

**What it does:**
1. Runs the coverage command (`npm run coverage`, etc.)
2. Identifies the most important user-facing feature lacking tests
3. Writes ONE meaningful test validating real behavior
4. Verifies coverage increased as a side effect
5. Commits with message: `test(<file>): <describe user behavior tested>`

**Philosophy:** Don't write tests just to increase coverage. Use coverage as a guide to find untested user-facing behavior. Prioritize error handling, CLI commands, API endpoints, and file parsing over internal utilities.

**Completion criteria:** Coverage reaches target or 100%.

### linting

Cleans up lint errors and type errors systematically, one fix per iteration.

```bash
task-master loop -n 20 --prompt linting
```

**What it does:**
1. Runs lint command (`npm run lint`, `eslint .`, etc.)
2. Runs type check (`tsc --noEmit`, etc.)
3. Picks ONE error to fix, prioritizing:
   - Type errors (breaks builds)
   - Security-related lint errors
   - Errors in frequently-changed files
4. Fixes with minimal changes - no surrounding refactoring
5. Commits with message: `fix(<file>): <describe error fixed>`

**Completion criteria:** Zero lint errors and zero type errors.

### duplication

Finds duplicated code using detection tools and refactors into shared utilities.

```bash
task-master loop -n 10 --prompt duplication
```

**What it does:**
1. Runs duplication detection (`npx jscpd .` or similar)
2. Reviews the report and picks ONE clone to refactor, prioritizing:
   - Larger clones (more lines = more maintenance burden)
   - Clones in frequently-changed files
   - Clones with slight variations
3. Extracts duplicated code into a shared utility
4. Updates all clone locations to use the shared utility
5. Runs tests to verify behavior is preserved

**Completion criteria:** Duplication below threshold (e.g., <3%).

### entropy

Targets code smells that increase cognitive load and maintenance burden.

```bash
task-master loop -n 10 --prompt entropy
```

**Code smells targeted:**
- Long functions (>60 lines) → extract into smaller functions
- Deep nesting (>3 levels) → use early returns, extract conditions
- Large files (>500 lines) → split into focused modules
- Magic numbers → extract into named constants
- Complex conditionals → extract into well-named functions
- God classes → split responsibilities

**What it does:**
1. Scans codebase for code smells (uses judgment or tools like `complexity-report`)
2. Picks ONE smell to fix, prioritizing smells in critical paths
3. Refactors with minimal changes - no over-engineering
4. Runs tests to verify behavior is preserved

**Completion criteria:** No significant code smells remain.

---

<Tip>
The loop command is perfect for "overnight automation" - start a loop before leaving and return to a cleaned-up codebase.
</Tip>
