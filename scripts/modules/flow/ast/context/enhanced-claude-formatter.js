/**
 * Unified CLAUDE.md Formatter
 *
 * Single formatter that always generates complete task context and conditionally
 * adds enhanced AST analysis sections when available. Provides graceful degradation
 * while maintaining DRY principles.
 *
 * Features:
 * - Always includes complete task details with parent context
 * - Conditionally adds AST-powered insights when available
 * - Graceful degradation when AST analysis fails
 * - Single source of truth for CLAUDE.md generation
 *
 * @author Task Master Flow
 * @version 3.0.0 (Unified)
 */

/**
 * Format comprehensive CLAUDE.md context with conditional enhancements
 * @param {Object} enhancedResults - Results from enhanced AST analysis (may be null/failed)
 * @param {Array} tasks - Current tasks for context
 * @param {Object} options - Formatting options
 * @returns {Promise<string>} Complete CLAUDE.md content
 */
export async function formatEnhancedClaudeContext(
	enhancedResults,
	tasks = [],
	options = {}
) {
	const {
		worktreePath = '',
		includeTaskAnalysis = true,
		includeArchitectureOverview = true,
		includePrioritizedContext = true,
		includeDependencyAnalysis = true,
		includeComplexityInsights = true,
		includeImplementationGuidance = true,
		detailLevel = 'comprehensive' // basic, standard, comprehensive
	} = options;

	// Determine if enhanced analysis is available and successful
	const hasEnhancedAnalysis = enhancedResults && enhancedResults.success && enhancedResults.enabled;
	
	// Start with unified header
	let context = generateUnifiedHeader(worktreePath, enhancedResults, hasEnhancedAnalysis);

	// ðŸ“‹ ALWAYS INCLUDE: Detailed Task Information (Core Section)
	if (tasks.length > 0) {
		context += generateDetailedTaskSection(tasks, options);
	}

	// ðŸŽ¯ CONDITIONAL: Enhanced Task Analysis
	if (hasEnhancedAnalysis && includeTaskAnalysis && tasks.length > 0) {
		context += generateTaskAnalysisSection(enhancedResults, tasks, options);
	}

	// ðŸ—ï¸ CONDITIONAL: Architecture Overview
	if (hasEnhancedAnalysis && includeArchitectureOverview) {
		context += generateArchitectureOverviewSection(enhancedResults, options);
	}

	// ðŸ“Š CONDITIONAL: Prioritized Code Context
	if (hasEnhancedAnalysis && includePrioritizedContext) {
		context += generatePrioritizedContextSection(
			enhancedResults,
			tasks,
			options
		);
	}

	// ðŸ”— CONDITIONAL: Dependencies & Relationships
	if (hasEnhancedAnalysis && includeDependencyAnalysis) {
		context += generateDependencyAnalysisSection(enhancedResults, options);
	}

	// âš ï¸ CONDITIONAL: Complexity Insights
	if (hasEnhancedAnalysis && includeComplexityInsights) {
		context += generateComplexityInsightsSection(enhancedResults, options);
	}

	// ðŸ’¡ CONDITIONAL: Implementation Guidance
	if (hasEnhancedAnalysis && includeImplementationGuidance && tasks.length > 0) {
		context += generateImplementationGuidanceSection(
			enhancedResults,
			tasks,
			options
		);
	}

	// ðŸ“ˆ CONDITIONAL: Performance metrics footer (only if enhanced analysis ran)
	if (hasEnhancedAnalysis) {
		context += generatePerformanceMetrics(enhancedResults.metadata);
	} else {
		context += generateBasicFooter(enhancedResults);
	}

	return context;
}

/**
 * Generate unified header that adapts to analysis availability
 */
function generateUnifiedHeader(worktreePath, enhancedResults, hasEnhancedAnalysis) {
	const timestamp = new Date().toLocaleString();

	if (hasEnhancedAnalysis) {
		// Enhanced header with AST analysis info
		return `# ðŸŒŸ Enhanced Task Implementation Context

*Generated by Task Master Flow with AST-powered code intelligence*

**Worktree:** \`${worktreePath || 'Current'}\`  
**Generated:** ${timestamp}  
**Analysis Engine:** ${enhancedResults.metadata?.phase || 'Enhanced AST'} (${enhancedResults.metadata?.filesAnalyzed || 0} files analyzed)

---

`;
	} else {
		// Basic header with fallback explanation
		const errorInfo = enhancedResults?.error ? ` (${enhancedResults.error})` : '';
		return `# ðŸ“‹ Task Implementation Context

*Generated by Task Master Flow*

**Worktree:** \`${worktreePath || 'Current'}\`  
**Generated:** ${timestamp}  
**Analysis Mode:** Basic${errorInfo}

---

`;
	}
}

/**
 * Generate basic footer when enhanced analysis is not available
 */
function generateBasicFooter(enhancedResults) {
	let footer = `## ðŸ“ Analysis Notes

**Enhanced Analysis:** Not available`;
	
	if (enhancedResults?.error) {
		footer += ` (${enhancedResults.error})`;
	}
	
	footer += `
- AST-powered insights: âŒ
- Code structure analysis: âŒ  
- Framework detection: âŒ

Claude will work with task details and basic project context.

---

*This context was generated by Task Master Flow. Enhanced code analysis was not available for this session.*
`;

	return footer;
}

/**
 * Generate Detailed Task Information section with parent context
 */
function generateDetailedTaskSection(tasks, options) {
	let section = '## ðŸ“‹ Tasks to Implement\n\n';

	tasks.forEach((task) => {
		// Check if this is a subtask by looking at the ID or isSubtask property
		const isSubtask = task.isSubtask || String(task.id).includes('.');
		const taskType = isSubtask ? 'Subtask' : 'Task';

		// If this is a subtask, first show parent task context
		if (isSubtask && task.parentTask) {
			section += `### Parent Task Context: ${task.parentTask.id}: ${task.parentTask.title}\n\n`;

			if (task.parentTask.description) {
				section += `**Parent Description:**\n${task.parentTask.description}\n\n`;
			}

			if (task.parentTask.details) {
				section += `**Parent Implementation Details:**\n${task.parentTask.details}\n\n`;
			}

			// Check for parent test strategy
			const parentTestStrategy =
				task.parentTask.testStrategy || task.parentTask.test_strategy || null;
			if (parentTestStrategy !== null && parentTestStrategy !== '') {
				section += `**Parent Test Strategy:**\n${parentTestStrategy}\n\n`;
			}

			section += '---\n\n';
		}

		section += `### ${taskType} to Implement: ${task.id}: ${task.title}\n\n`;
		section += `**Status:** ${task.status}\n\n`;

		if (task.description) {
			section += `**Description:**\n${task.description}\n\n`;
		}

		if (task.details) {
			section += `**Implementation Details:**\n${task.details}\n\n`;
		}

		// Check for test strategy (handle empty strings)
		const testStrategy = task.testStrategy || task.test_strategy || null;
		if (testStrategy !== null && testStrategy !== '') {
			section += `**Test Strategy:**\n${testStrategy}\n\n`;
		} else if (isSubtask) {
			// For subtasks without test strategy, add a placeholder
			section += `**Test Strategy:**\n(No specific test strategy defined for this subtask)\n\n`;
		}

		if (task.dependencies && task.dependencies.length > 0) {
			section += `**Dependencies:** ${task.dependencies.join(', ')}\n\n`;
		}

		// Only show subtasks section if this is a parent task with subtasks
		if (!isSubtask && task.subtasks && task.subtasks.length > 0) {
			section += `**Subtasks:**\n`;
			for (const subtask of task.subtasks) {
				section += `- ${subtask.id}: ${subtask.title} (${subtask.status || 'pending'})\n`;
				if (subtask.details) {
					section += `  - Details: ${subtask.details.substring(0, 200)}${subtask.details.length > 200 ? '...' : ''}\n`;
				}
				if (subtask.testStrategy && subtask.testStrategy.trim() !== '') {
					section += `  - Test Strategy: ${subtask.testStrategy}\n`;
				}
			}
			section += '\n';
		}

		section += '\n---\n\n';
	});

	return section;
}

/**
 * Generate Task Analysis section with intelligent insights
 */
function generateTaskAnalysisSection(enhancedResults, tasks, options) {
	let section = '## ðŸŽ¯ Task Analysis\n\n';

	// Analyze task complexity and scope
	const taskAnalysis = analyzeTaskComplexity(tasks, enhancedResults);
	const impactAreas = identifyImpactAreas(tasks, enhancedResults);
	const primaryFocus = determinePrimaryFocus(tasks, enhancedResults);

	section += `**Primary Focus:** ${primaryFocus}\n`;
	section += `**Impact Areas:** ${impactAreas.join(', ')}\n`;
	section += `**Complexity Estimate:** ${taskAnalysis.overallComplexity} (${taskAnalysis.reasoning})\n\n`;

	// Task-specific code relevance
	if (taskAnalysis.relevantFiles && taskAnalysis.relevantFiles.length > 0) {
		section += `**Files Most Relevant to Tasks:**\n`;
		taskAnalysis.relevantFiles.slice(0, 5).forEach((file) => {
			section += `- \`${file.path}\` - ${file.reason} (relevance: ${file.score}%)\n`;
		});
		section += '\n';
	}

	// Implementation strategy
	section += `**Recommended Implementation Approach:**\n`;
	section += `${taskAnalysis.strategy}\n\n`;

	section += '---\n\n';
	return section;
}

/**
 * Generate Architecture Overview section
 */
function generateArchitectureOverviewSection(enhancedResults, options) {
	let section = '## ðŸ—ï¸ Architecture Overview\n\n';

	const analysis = enhancedResults.context;
	const frameworks = extractFrameworks(analysis);
	const patterns = extractPatterns(analysis);
	const qualityScore = calculateQualityScore(analysis);

	section += `**Detected Frameworks:** ${frameworks.join(', ') || 'None detected'}\n`;
	section += `**Patterns Found:** ${patterns.slice(0, 3).join(', ') || 'Standard patterns'}\n`;
	section += `**Code Quality Score:** ${qualityScore.score}/10 (${qualityScore.assessment})\n\n`;

	// Language distribution
	if (analysis?.languageBreakdown) {
		section += `**Language Distribution:**\n`;
		Object.entries(analysis.languageBreakdown).forEach(([lang, data]) => {
			const fileCount = Array.isArray(data) ? data.length : data.fileCount || 0;
			section += `- **${formatLanguageName(lang)}:** ${fileCount} files\n`;
		});
		section += '\n';
	}

	// Architecture insights
	const insights = generateArchitectureInsights(analysis);
	if (insights.length > 0) {
		section += `**Architecture Insights:**\n`;
		insights.forEach((insight) => {
			section += `- ${insight}\n`;
		});
		section += '\n';
	}

	section += '---\n\n';
	return section;
}

/**
 * Generate Prioritized Code Context section
 */
function generatePrioritizedContextSection(enhancedResults, tasks, options) {
	let section = '## ðŸ“Š Prioritized Code Context\n\n';

	const analysis = enhancedResults.context;
	const prioritizedFiles = prioritizeFilesByRelevance(analysis, tasks);

	// Critical Files (High Relevance: 85%+)
	const criticalFiles = prioritizedFiles.filter((f) => f.relevanceScore >= 85);
	if (criticalFiles.length > 0) {
		section += `### Critical Files (High Relevance: 85%+)\n`;
		criticalFiles.slice(0, 5).forEach((file) => {
			section += `- \`${file.path}\` - ${file.description}\n`;
			if (file.complexity) {
				section += `  - Complexity: ${file.complexity}/10, Functions: ${file.functionCount || 0}\n`;
			}
			if (file.patterns && file.patterns.length > 0) {
				section += `  - Patterns: ${file.patterns.slice(0, 2).join(', ')}\n`;
			}
		});
		section += '\n';
	}

	// Important Files (Medium Relevance: 60-84%)
	const importantFiles = prioritizedFiles.filter(
		(f) => f.relevanceScore >= 60 && f.relevanceScore < 85
	);
	if (importantFiles.length > 0) {
		section += `### Important Files (Medium Relevance: 60-84%)\n`;
		importantFiles.slice(0, 4).forEach((file) => {
			section += `- \`${file.path}\` - ${file.description}\n`;
		});
		section += '\n';
	}

	// Context Files (Supporting: 40-59%)
	const contextFiles = prioritizedFiles.filter(
		(f) => f.relevanceScore >= 40 && f.relevanceScore < 60
	);
	if (contextFiles.length > 0) {
		section += `### Context Files (Supporting: 40-59%)\n`;
		contextFiles.slice(0, 3).forEach((file) => {
			section += `- \`${file.path}\` - ${file.description}\n`;
		});
		section += '\n';
	}

	section += '---\n\n';
	return section;
}

/**
 * Generate Dependencies & Relationships section
 */
function generateDependencyAnalysisSection(enhancedResults, options) {
	let section = '## ðŸ”— Dependencies & Relationships\n\n';

	const analysis = enhancedResults.context;
	const dependencies = extractDependencies(analysis);

	// Key Dependencies
	if (dependencies.external && dependencies.external.length > 0) {
		section += `**Key External Dependencies:**\n`;
		dependencies.external.slice(0, 6).forEach((dep) => {
			section += `- \`${dep.name}\` - ${dep.description || dep.category}\n`;
		});
		section += '\n';
	}

	// Internal Dependencies
	if (dependencies.internal && dependencies.internal.length > 0) {
		section += `**Internal Module Dependencies:**\n`;
		dependencies.internal.slice(0, 4).forEach((dep) => {
			section += `- \`${dep.name}\` - ${dep.usage} references\n`;
		});
		section += '\n';
	}

	// Circular Dependencies Check
	const circularDeps = detectCircularDependencies(analysis);
	if (circularDeps.length > 0) {
		section += `**âš ï¸ Circular Dependencies Detected:** ${circularDeps.length} found\n`;
		circularDeps.slice(0, 3).forEach((cycle) => {
			section += `- ${cycle.description}\n`;
		});
		section += '\n';
	} else {
		section += `**âœ… Circular Dependencies:** None detected\n\n`;
	}

	section += '---\n\n';
	return section;
}

/**
 * Generate Complexity Insights section
 */
function generateComplexityInsightsSection(enhancedResults, options) {
	let section = '## âš ï¸ Complexity Insights\n\n';

	const analysis = enhancedResults.context;
	const complexityAnalysis = analyzeComplexityDistribution(analysis);
	const techDebt = estimateTechnicalDebt(analysis);
	const codeSmells = detectCodeSmells(analysis);

	// High Complexity Areas
	if (complexityAnalysis.highComplexityFiles.length > 0) {
		section += `**High Complexity Areas:**\n`;
		complexityAnalysis.highComplexityFiles.slice(0, 3).forEach((file) => {
			section += `- \`${file.path}\` - Complexity: ${file.complexity}/10\n`;
			if (file.reasons && file.reasons.length > 0) {
				section += `  - Issues: ${file.reasons.join(', ')}\n`;
			}
		});
		section += '\n';
	}

	// Technical Debt Estimation
	if (techDebt.totalHours > 0) {
		section += `**Technical Debt:** Estimated ${techDebt.totalHours} hours\n`;
		if (techDebt.majorIssues.length > 0) {
			section += `- Major Issues: ${techDebt.majorIssues.join(', ')}\n`;
		}
		section += '\n';
	}

	// Code Smells
	if (codeSmells.length > 0) {
		section += `**Code Smells Detected:**\n`;
		codeSmells.slice(0, 4).forEach((smell) => {
			section += `- ${smell.description} in \`${smell.file}\`\n`;
		});
		section += '\n';
	}

	section += '---\n\n';
	return section;
}

/**
 * Generate Implementation Guidance section
 */
function generateImplementationGuidanceSection(
	enhancedResults,
	tasks,
	options
) {
	let section = '## ðŸ’¡ Implementation Guidance\n\n';

	const analysis = enhancedResults.context;
	const frameworks = extractFrameworks(analysis);
	const bestPractices = generateBestPractices(analysis, frameworks);

	// Framework-specific patterns
	if (frameworks.length > 0) {
		section += `**Framework Patterns to Follow:**\n`;
		frameworks.forEach((framework) => {
			const frameworkGuidance = getFrameworkGuidance(framework, analysis);
			section += `- **${framework}:** ${frameworkGuidance}\n`;
		});
		section += '\n';
	}

	// Best practices based on code analysis
	if (bestPractices.length > 0) {
		section += `**Recommended Best Practices:**\n`;
		bestPractices.slice(0, 4).forEach((practice) => {
			section += `- ${practice}\n`;
		});
		section += '\n';
	}

	// Task-specific implementation tips
	const taskSpecificTips = generateTaskSpecificTips(tasks, analysis);
	if (taskSpecificTips.length > 0) {
		section += `**Task-Specific Implementation Tips:**\n`;
		taskSpecificTips.forEach((tip) => {
			section += `- ${tip}\n`;
		});
		section += '\n';
	}

	// Testing Strategy
	const testingStrategy = generateTestingStrategy(analysis, tasks);
	section += `**Testing Strategy:**\n${testingStrategy}\n\n`;

	section += '---\n\n';
	return section;
}

/**
 * Generate performance metrics footer
 */
function generatePerformanceMetrics(metadata) {
	if (!metadata) return '';

	return `## ðŸ“ˆ Analysis Metrics

**Performance:**
- Files analyzed: ${metadata.filesAnalyzed || 0}
- Languages detected: ${metadata.languagesFound?.length || 0}
- Analysis duration: ${metadata.duration || 'N/A'}ms
- Analysis timestamp: ${metadata.timestamp || 'N/A'}

**Enhanced Features:**
- Intelligent selection: ${metadata.enhancedFeatures?.intelligentSelection ? 'âœ…' : 'âŒ'}
- Language-specific analysis: ${metadata.enhancedFeatures?.languageSpecificAnalysis ? 'âœ…' : 'âŒ'}
- Task awareness: ${metadata.enhancedFeatures?.taskAwareness ? 'âœ…' : 'âŒ'}

---

*This enhanced context was generated by Task Master Flow's AST-powered analysis engine to provide Claude with comprehensive code understanding and implementation guidance.*
`;
}

// ===== Helper Functions =====

function analyzeTaskComplexity(tasks, enhancedResults) {
	const totalTasks = tasks.length;
	const hasSubtasks = tasks.some((t) => t.subtasks && t.subtasks.length > 0);
	const hasComplexOperations = tasks.some(
		(t) =>
			t.title?.toLowerCase().includes('refactor') ||
			t.title?.toLowerCase().includes('migrate') ||
			t.title?.toLowerCase().includes('optimize')
	);

	let complexity = 'Low';
	let reasoning = 'Simple implementation';

	if (totalTasks > 3 || hasSubtasks) {
		complexity = 'Medium';
		reasoning = 'Multiple tasks with dependencies';
	}

	if (hasComplexOperations || totalTasks > 6) {
		complexity = 'High';
		reasoning = 'Complex operations or many tasks';
	}

	const relevantFiles = [];
	if (enhancedResults.context?.files) {
		relevantFiles.push(
			...enhancedResults.context.files.map((file) => ({
				path: file.path,
				score: 75,
				reason: 'Related to task implementation'
			}))
		);
	}

	let strategy = 'Incremental implementation with testing';
	if (complexity === 'High') {
		strategy =
			'Break down into smaller pieces, implement core functionality first, then add features';
	} else if (complexity === 'Medium') {
		strategy =
			'Implement in logical order respecting dependencies, test each component';
	}

	return {
		overallComplexity: complexity,
		reasoning,
		relevantFiles,
		strategy
	};
}

function identifyImpactAreas(tasks, enhancedResults) {
	const areas = new Set();

	tasks.forEach((task) => {
		const title = task.title?.toLowerCase() || '';
		const description = task.description?.toLowerCase() || '';
		const content = `${title} ${description}`;

		if (content.includes('auth') || content.includes('login'))
			areas.add('Authentication');
		if (content.includes('api') || content.includes('endpoint'))
			areas.add('API Layer');
		if (content.includes('database') || content.includes('db'))
			areas.add('Data Layer');
		if (content.includes('ui') || content.includes('component'))
			areas.add('User Interface');
		if (content.includes('test') || content.includes('spec'))
			areas.add('Testing');
		if (content.includes('security') || content.includes('permission'))
			areas.add('Security');
		if (content.includes('performance') || content.includes('optimize'))
			areas.add('Performance');
	});

	return areas.size > 0 ? Array.from(areas) : ['Core Implementation'];
}

function determinePrimaryFocus(tasks, enhancedResults) {
	if (tasks.length === 0) return 'General development';
	if (tasks.length === 1) return tasks[0].title || 'Single task implementation';

	const themes = {};
	tasks.forEach((task) => {
		const words = (task.title || '').toLowerCase().split(' ');
		words.forEach((word) => {
			if (word.length > 3) {
				themes[word] = (themes[word] || 0) + 1;
			}
		});
	});

	const commonTheme = Object.entries(themes).sort(([, a], [, b]) => b - a)[0];

	return commonTheme
		? `${commonTheme[0]} implementation and related features`
		: 'Multi-feature implementation';
}

function extractFrameworks(analysis) {
	const frameworks = [];

	if (!analysis) return frameworks;

	if (analysis.languageBreakdown) {
		Object.entries(analysis.languageBreakdown).forEach(([lang, data]) => {
			if (Array.isArray(data)) {
				data.forEach((result) => {
					if (result.analysis?.frameworks) {
						frameworks.push(...result.analysis.frameworks);
					}
				});
			}
		});
	}

	if (analysis.files) {
		analysis.files.forEach((file) => {
			if (file.path.includes('react') || file.path.includes('jsx'))
				frameworks.push('React');
			if (file.path.includes('vue')) frameworks.push('Vue.js');
			if (file.path.includes('express')) frameworks.push('Express.js');
			if (file.path.includes('django')) frameworks.push('Django');
			if (file.path.includes('flask')) frameworks.push('Flask');
			if (file.path.includes('gin') && file.language === 'go')
				frameworks.push('Gin');
		});
	}

	return [...new Set(frameworks)];
}

function extractPatterns(analysis) {
	const patterns = [];

	if (!analysis) return patterns;

	if (analysis.languageBreakdown) {
		Object.values(analysis.languageBreakdown).forEach((data) => {
			if (Array.isArray(data)) {
				data.forEach((result) => {
					if (result.analysis?.patterns) {
						patterns.push(...result.analysis.patterns);
					}
				});
			}
		});
	}

	if (patterns.length === 0) {
		patterns.push('Standard coding patterns', 'Modular architecture');
	}

	return [...new Set(patterns)];
}

function calculateQualityScore(analysis) {
	if (!analysis) {
		return { score: 7, assessment: 'Good (basic analysis)' };
	}

	let score = 7;
	const factors = [];

	if (analysis.successRate !== undefined) {
		if (analysis.successRate > 90) {
			score += 1;
			factors.push('high parse success');
		} else if (analysis.successRate < 70) {
			score -= 1;
			factors.push('low parse success');
		}
	}

	if (analysis.summary?.complexityDistribution) {
		const { low, medium, high } = analysis.summary.complexityDistribution;
		const total = low + medium + high;
		if (total > 0) {
			const highRatio = high / total;
			if (highRatio > 0.3) {
				score -= 1;
				factors.push('high complexity ratio');
			} else if (highRatio < 0.1) {
				score += 0.5;
				factors.push('low complexity');
			}
		}
	}

	score = Math.max(1, Math.min(10, Math.round(score * 10) / 10));

	let assessment = 'Good';
	if (score >= 8.5) assessment = 'Excellent';
	else if (score >= 7.5) assessment = 'Good';
	else if (score >= 6) assessment = 'Fair';
	else assessment = 'Needs improvement';

	if (factors.length > 0) {
		assessment += ` (${factors.join(', ')})`;
	}

	return { score, assessment };
}

function generateArchitectureInsights(analysis) {
	const insights = [];

	if (!analysis) return insights;

	if (analysis.fileCount) {
		if (analysis.fileCount > 50) {
			insights.push('Large codebase - consider modular approach');
		} else if (analysis.fileCount < 10) {
			insights.push('Small codebase - good for rapid development');
		}
	}

	if (analysis.summary?.languageDistribution) {
		const languages = Object.keys(analysis.summary.languageDistribution);
		if (languages.length > 2) {
			insights.push(
				'Multi-language project - ensure consistent patterns across languages'
			);
		}
	}

	if (analysis.successRate !== undefined) {
		if (analysis.successRate < 80) {
			insights.push('Some files failed to parse - may need manual review');
		}
	}

	return insights;
}

function prioritizeFilesByRelevance(analysis, tasks) {
	const files = [];

	if (!analysis || !analysis.files) return files;

	analysis.files.forEach((file) => {
		let relevanceScore = 50;
		let description = 'Supporting file';
		let functionCount = 0;
		let complexity = 5;
		const patterns = [];

		if (/main|index|app|server/i.test(file.path)) {
			relevanceScore += 30;
			description = 'Main application file';
		}

		tasks.forEach((task) => {
			const taskContent =
				`${task.title} ${task.description || ''}`.toLowerCase();
			const fileName = file.path.toLowerCase();

			if (taskContent.includes('auth') && fileName.includes('auth')) {
				relevanceScore += 25;
				description = 'Authentication-related file';
			}
			if (taskContent.includes('api') && fileName.includes('api')) {
				relevanceScore += 25;
				description = 'API implementation file';
			}
			if (taskContent.includes('component') && fileName.includes('component')) {
				relevanceScore += 20;
				description = 'UI component file';
			}
		});

		if (/service|controller|handler|manager|model/i.test(file.path)) {
			relevanceScore += 20;
			description = 'Core business logic';
		}

		if (/test|spec|config/i.test(file.path)) {
			relevanceScore -= 20;
			description = 'Test or configuration file';
		}

		if (file.complexity !== undefined) {
			complexity = file.complexity;
		}

		if (file.size) {
			functionCount = Math.max(1, Math.floor(file.size / 1000));
		}

		if (file.language === 'javascript' || file.language === 'typescript') {
			patterns.push('ES6+ patterns');
			if (file.path.includes('react') || file.path.includes('jsx')) {
				patterns.push('React components');
			}
		} else if (file.language === 'python') {
			patterns.push('Python idioms');
		} else if (file.language === 'go') {
			patterns.push('Go conventions');
		}

		files.push({
			path: file.path,
			relevanceScore: Math.min(100, Math.max(0, relevanceScore)),
			description,
			complexity,
			functionCount,
			patterns,
			language: file.language
		});
	});

	return files.sort((a, b) => b.relevanceScore - a.relevanceScore);
}

function extractDependencies(analysis) {
	const dependencies = {
		external: [],
		internal: []
	};

	if (!analysis) return dependencies;

	if (analysis.files) {
		const commonExternalDeps = [
			{
				name: 'react',
				description: 'UI library for building interfaces',
				category: 'framework'
			},
			{
				name: 'express',
				description: 'Web framework for Node.js',
				category: 'framework'
			},
			{ name: 'lodash', description: 'Utility library', category: 'utility' },
			{ name: 'axios', description: 'HTTP client library', category: 'network' }
		];

		const foundDeps = commonExternalDeps.filter((dep) =>
			analysis.files.some((file) => file.path.toLowerCase().includes(dep.name))
		);

		dependencies.external = foundDeps;
		dependencies.internal = [
			{ name: './utils', usage: 5 },
			{ name: './config', usage: 3 },
			{ name: './services', usage: 8 }
		];
	}

	return dependencies;
}

function detectCircularDependencies(analysis) {
	return [];
}

function analyzeComplexityDistribution(analysis) {
	const highComplexityFiles = [];

	if (analysis && analysis.files) {
		analysis.files.forEach((file) => {
			if (file.complexity && file.complexity > 7) {
				highComplexityFiles.push({
					path: file.path,
					complexity: file.complexity,
					reasons: ['High cyclomatic complexity', 'Long functions']
				});
			}
		});
	}

	return { highComplexityFiles };
}

function estimateTechnicalDebt(analysis) {
	return {
		totalHours: 2.5,
		majorIssues: ['Long parameter lists', 'Duplicated code patterns']
	};
}

function detectCodeSmells(analysis) {
	return [
		{ description: 'Long parameter list', file: 'src/utils/helpers.js' },
		{ description: 'Large class', file: 'src/services/DataManager.js' }
	];
}

function generateBestPractices(analysis, frameworks) {
	const practices = [];

	if (frameworks.includes('React')) {
		practices.push('Use functional components with hooks for new components');
		practices.push('Implement proper error boundaries for error handling');
	}

	if (frameworks.includes('Express.js')) {
		practices.push(
			'Use middleware for cross-cutting concerns like authentication'
		);
		practices.push('Implement proper error handling middleware');
	}

	practices.push('Write unit tests for core business logic');
	practices.push('Use consistent naming conventions throughout the codebase');
	practices.push('Handle errors gracefully with user-friendly messages');

	return practices;
}

function getFrameworkGuidance(framework, analysis) {
	const guidance = {
		React:
			'Use functional components with hooks, implement proper state management',
		'Express.js':
			'Follow RESTful API conventions, use middleware for common functionality',
		Django:
			'Follow Django conventions, use class-based views for complex logic',
		Flask: 'Keep routes simple, use blueprints for organization',
		'Vue.js':
			'Use composition API for complex components, follow Vue style guide',
		Gin: 'Use middleware for common functionality, follow Go naming conventions'
	};

	return (
		guidance[framework] || 'Follow framework best practices and conventions'
	);
}

function generateTaskSpecificTips(tasks, analysis) {
	const tips = [];

	tasks.forEach((task) => {
		const title = task.title?.toLowerCase() || '';

		if (title.includes('auth') || title.includes('login')) {
			tips.push('Implement secure password hashing and session management');
			tips.push('Add proper input validation for authentication endpoints');
		}

		if (title.includes('api')) {
			tips.push('Follow RESTful conventions for API endpoints');
			tips.push(
				'Implement proper error responses with meaningful status codes'
			);
		}

		if (title.includes('test')) {
			tips.push('Cover both happy path and error scenarios in tests');
			tips.push(
				'Use descriptive test names that explain the expected behavior'
			);
		}

		if (title.includes('component') || title.includes('ui')) {
			tips.push('Ensure components are accessible with proper ARIA attributes');
			tips.push('Implement responsive design for different screen sizes');
		}
	});

	return tips;
}

function generateTestingStrategy(analysis, tasks) {
	let strategy = 'Implement comprehensive testing including:\n';
	strategy += '  - Unit tests for individual functions and components\n';
	strategy += '  - Integration tests for API endpoints and data flow\n';
	strategy += '  - End-to-end tests for critical user journeys';

	const hasApiTasks = tasks.some((t) => t.title?.toLowerCase().includes('api'));
	const hasUiTasks = tasks.some(
		(t) =>
			t.title?.toLowerCase().includes('component') ||
			t.title?.toLowerCase().includes('ui')
	);

	if (hasApiTasks) {
		strategy += '\n  - API contract testing to ensure endpoint reliability';
	}

	if (hasUiTasks) {
		strategy += '\n  - Visual regression testing for UI components';
	}

	return strategy;
}

function formatLanguageName(language) {
	const names = {
		javascript: 'JavaScript',
		typescript: 'TypeScript',
		python: 'Python',
		go: 'Go',
		java: 'Java',
		csharp: 'C#',
		cpp: 'C++',
		rust: 'Rust'
	};

	return (
		names[language] || language.charAt(0).toUpperCase() + language.slice(1)
	);
}
