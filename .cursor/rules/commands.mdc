---
description: Guidelines for implementing CLI commands using Commander.js
globs: scripts/modules/commands.js
alwaysApply: false
---
---
description: Guidelines for implementing CLI commands using Commander.js
globs: scripts/modules/commands.js
alwaysApply: false
---

# Command-Line Interface Implementation Guidelines

**Note on Interaction Method:**

While this document details the implementation of Task Master's **CLI commands**, the **preferred method for interacting with Task Master in integrated environments (like Cursor) is through the MCP server tools**. 

- **Use MCP Tools First**: Always prefer using the MCP tools (e.g., `get_tasks`, `add_task`) when interacting pr via an integrated tool. They offer better performance, structured data, and richer error handling. See [`taskmaster.mdc`](mdc:.cursor/rules/taskmaster.mdc) for a comprehensive list of MCP tools and their corresponding CLI commands.
- **CLI as Fallback/User Interface**: The `task-master` CLI commands described here are primarily intended for:
    - Direct user interaction in the terminal.
    - A fallback mechanism if the MCP server is unavailable or a specific functionality is not exposed via an MCP tmentation Context**: This document (`commands.mdc`) focuses on the standards for *implementing* the CLI commands using Commander.js within the [`commands.js`](mdc:scripts/modules/commands.js) module.

## Command Structure Standards

- **Basic Command Template**:
  ```javascript
  // ✅ DO: Follow this structure for all commands
  programInstance
    .command('command-name')
    .description('Clear, concise description of what the command does')
    .option('-s, --short-option <value>', 'Option description', 'default value')
    .option('--long-option <value>', 'Option description')
    .action(async (options) => {
      // Command implementation
    });
  ```

- **Command Handler Organization**:
  - ✅ DO: Keep action handlers concise and focused
  - ✅ DO: Extract core functionality to appropriate modules
  - ✅ DO: Include validation for required parameters
  - ❌ DON'T: Implement business logic in command handlers

## Best Practices for Removal/Delete Commands

When implementing commands that delete or remove data (like `remove-task` or `remove-subtask`), follow these specific guidelines:

- **Confirmation Prompts**:
  - ✅ **DO**: Include a confirmation prompt by default for destructive operations
  - ✅ **DO**: Provide a `--yes` or `-y` flag to skip confirmation for scripting/automation
  - ✅ **DO**: Show what will be deleted in the confirmation message
  - ❌ **DON'T**: Perform destructive operations without user confirmation unless explicitly overridden

  ```javascript
  // ✅ DO: Include confirmation for destructive operations
  programInstance
    .command('remove-task')
    .description('Remove a task or subtask permanently')
    .option('-i, --id <id>', 'ID of the task to remove')
    .option('-y, --yes', 'Skip confirmation prompt', false)
    .action(async (options) => {
      // Validation code...
      
      if (!options.yes) {
        const confirm = await inquirer.prompt([{
          type: 'confirm',
          name: 'proceed',
          message: `Are you sure you want to permanently delete task ${taskId}? This cannot be undone.`,
          default: false
        }]);
        
        if (!confirm.proceed) {
          console.log(chalk.yellow('Operation cancelled.'));
          return;
        }
      }
      
      // Proceed with removal...
    });
  ```

- **File Path Handling**:
  - ✅ **DO**: Use `path.join()` to construct file paths
  - ✅ **DO**: Follow established naming conventions for tasks (e.g., `task_001.txt`)
  - ✅ **DO**: Check if files exist before attempting to delete them
  - ✅ **DO**: Handle file deletion errors gracefully
  - ❌ **DON'T**: Construct paths with string concatenation

  ```javascript
  // ✅ DO: Properly construct file paths
  const taskFilePath = path.join(
    path.dirname(tasksPath),
    `task_${taskId.toString().padStart(3, '0')}.txt`
  );
  
  // ✅ DO: Check existence before deletion
  if (fs.existsSync(taskFilePath)) {
    try {
      fs.unlinkSync(taskFilePath);
      console.log(chalk.green(`Task file deleted: ${taskFilePath}`));
    } catch (error) {
      console.warn(chalk.yellow(`Could not delete task file: ${error.message}`));
    }
  }
  ```

- **Clean Up References**:
  - ✅ **DO**: Clean up references to the deleted item in other parts of the data
  - ✅ **DO**: Handle both direct and indirect references
  - ✅ **DO**: Explain what related data is being updated
  - ❌ **DON'T**: Leave dangling references

  ```javascript
  // ✅ DO: Clean up references when deleting items
  console.log(chalk.blue('Cleaning up task dependencies...'));
  let referencesRemoved = 0;
  
  // Update dependencies in other tasks
  data.tasks.forEach(task => {
    if (task.dependencies && task.dependencies.includes(taskId)) {
      task.dependencies = task.dependencies.filter(depId => depId !== taskId);
      referencesRemoved++;
    }
  });
  
  if (referencesRemoved > 0) {
    console.log(chalk.green(`Removed ${referencesRemoved} references to task ${taskId} from other tasks`));
  }
  ```

- **Task File Regeneration**:
  - ✅ **DO**: Regenerate task files after destructive operations
  - ✅ **DO**: Pass all required parameters to generation functions
  - ✅ **DO**: Provide an option to skip regeneration if needed
  - ❌ **DON'T**: Assume default parameters will work

  ```javascript
  // ✅ DO: Properly regenerate files after deletion
  if (!options.skipGenerate) {
    console.log(chalk.blue('Regenerating task files...'));
    try {
      // Note both parameters are explicitly provided
      await generateTaskFiles(tasksPath, path.dirname(tasksPath));
      console.log(chalk.green('Task files regenerated successfully'));
    } catch (error) {
      console.warn(chalk.yellow(`Warning: Could not regenerate task files: ${error.message}`));
    }
  }
  ```

- **Alternative Suggestions**:
  - ✅ **DO**: Suggest non-destructive alternatives when appropriate
  - ✅ **DO**: Explain the difference between deletion and status changes
  - ✅ **DO**: Include examples of alternative commands

  ```javascript
  // ✅ DO: Suggest alternatives for destructive operations
  console.log(chalk.yellow('Note: If you just want to exclude this task from active work, consider:'));
  console.log(chalk.cyan(`  task-master set-status --id='${taskId}' --status='cancelled'`));
  console.log(chalk.cyan(`  task-master set-status --id='${taskId}' --status='deferred'`));
  console.log('This preserves the task and its history for reference.');
  ```

## Option Naming Conventions

- **Command Names**:
  - ✅ DO: Use kebab-case for command names (`analyze-complexity`)
  - ❌ DON'T: Use camelCase for command names (`analyzeComplexity`)
  - ✅ DO: Use descriptive, action-oriented names

- **Option Names**:
  - ✅ DO: Use kebab-case for long-form option names (`--output-format`)
  - ✅ DO: Provide single-letter shortcuts when appropriate (`-f, --file`)
  - ✅ DO: Use consistent option names across similar commands
  - ❌ DON'T: Use different names for the same concept (`--file` in one command, `--path` in another)

  ```javascript
  // ✅ DO: Use consistent option naming
  .option('-f, --file <path>', 'Path to the tasks file', 'tasks/tasks.json')
  .option('-o, --output <dir>', 'Output directory', 'tasks')
  
  // ❌ DON'T: Use inconsistent naming
  .option('-f, --file <path>', 'Path to the tasks file')
  .option('-p, --path <dir>', 'Output directory') // Should be --output
  ```

  > **Note**: Although options are defined with kebab-case (`--num-tasks`), Commander.js stores them internally as camelCase properties. Access them in code as `options.numTasks`, not `options['num-tasks']`.

- **Boolean Flag Conventions**:
  - ✅ DO: Use positive flags with `--skip-` prefix for disabling behavior
  - ❌ DON'T: Use negated boolean flags with `--no-` prefix
  - ✅ DO: Use consistent flag handling across all commands

  ```javascript
  // ✅ DO: Use positive flag with skip- prefix 
  .option('--skip-generate', 'Skip generating task files')
  
  // ❌ DON'T: Use --no- prefix 
  .option('--no-generate', 'Skip generating task files')
  ```

  > **Important**: When handling boolean flags in the code, make your intent clear:
  ```javascript
  // ✅ DO: Use clear variable naming that matches the flag's intent
  const generateFiles = !options.skipGenerate;
  
  // ❌ DON'T: Use confusing double negatives
  const dontSkipGenerate = !options.skipGenerate;
  ```

## Input Validation

- **Required Parameters**:
  - ✅ DO: Check that required parameters are provided
  - ✅ DO: Provide clear error messages when parameters are missing
  - ✅ DO: Use early returns with process.exit(1) for validation failures

  ```javascript
  // ✅ DO: Validate required parameters early
  if (!prompt) {
    console.error(chalk.red('Error: --prompt parameter is required. Please provide a task description.'));
    process.exit(1);
  }
  ```

- **Parameter Type Conversion**:
  - ✅ DO: Convert string inputs to appropriate types (numbers, booleans)
  - ✅ DO: Handle conversion errors gracefully

  ```javascript
  // ✅ DO: Parse numeric parameters properly
  const fromId = parseInt(options.from, 10);
  if (isNaN(fromId)) {
    console.error(chalk.red('Error: --from must be a valid number'));
    process.exit(1);
  }
  ```

- **Enhanced Input Validation**:
  - ✅ DO: Validate file existence for critical file operations
  - ✅ DO: Provide context-specific validation for identifiers
  - ✅ DO: Check required API keys for features that depend on them

  ```javascript
  // ✅ DO: Validate file existence
  if (!fs.existsSync(tasksPath)) {
    console.error(chalk.red(`Error: Tasks file not found at path: ${tasksPath}`));
    if (tasksPath === 'tasks/tasks.json') {
```
