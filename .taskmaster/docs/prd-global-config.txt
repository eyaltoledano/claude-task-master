# Product Requirements Document: Global Configuration Support

## Overview

Task Master AI currently only supports project-local configuration files (`.taskmaster/config.json`), requiring users to duplicate configuration across multiple projects. This PRD defines the implementation of a global configuration system that follows XDG Base Directory specifications, allowing users to define default settings, custom providers, and API credentials once for all projects.

The global configuration will live at `$XDG_CONFIG_HOME/taskmaster/config.json` (falling back to `~/.config/taskmaster/config.json`), with the same structure as project-local configs. Local configs will override global settings using an atomic merge strategy for model configurations.

## Problem Statement

Current pain points:
1. **Configuration Duplication**: Users must manually copy configuration to every new project, including custom provider definitions and API keys
2. **Inconsistent Defaults**: No way to set personal defaults (preferred models, temperature settings, etc.) across all projects
3. **Custom Provider Management**: Custom AI providers must be configured separately in each project, hindering adoption
4. **Onboarding Friction**: New projects require full configuration setup even when user preferences are already known
5. **Missing XDG Compliance**: Does not follow standard Linux/Unix configuration conventions

## Goals & Objectives

### Primary Goals
1. Implement XDG-compliant global configuration discovery
2. Support identical config structure between global and local configs
3. Provide atomic merge strategy for model configurations
4. Maintain backward compatibility with existing project-local configs
5. Enable global custom provider definitions

### Secondary Goals
1. Support global environment variable storage (`$XDG_CONFIG_HOME/taskmaster/.env`)
2. Provide CLI commands for global config management
3. Add MCP tools for global config access
4. Improve onboarding experience for new projects

### Non-Goals (Future Enhancements)
1. Multiple named global profiles (e.g., "work", "personal")
2. Cloud-synced configuration
3. GUI configuration editor
4. Config file encryption

## User Stories

### Developer Workflow
**As a developer**, I want to define my preferred AI models globally, so that new projects automatically use my preferences without manual configuration.

**As a developer**, I want to store API keys in a global location, so that I don't have to copy them to every project or risk committing them to version control.

**As a power user**, I want to define custom AI providers once, so that all my projects can use them without repeating provider configuration.

**As a team lead**, I want to override global defaults on a per-project basis, so that specific projects can use different models/settings when needed.

### Configuration Management
**As an administrator**, I want Task Master to follow XDG specifications, so that configuration fits standard Linux/Unix conventions.

**As a user**, I want to see which settings come from global vs. local config, so that I can debug configuration issues.

**As a developer**, I want local model settings to completely override global ones, so that project-specific model choices aren't merged with global defaults.

## Requirements

### Functional Requirements

#### FR-1: XDG Config Directory Discovery
- **MUST** check `$XDG_CONFIG_HOME/taskmaster/config.json` first
- **MUST** fall back to `~/.config/taskmaster/config.json` if XDG var not set
- **MUST** fall back to `$HOME/.config/taskmaster/config.json` on macOS/Windows
- **SHOULD** create directory structure on first use if it doesn't exist

#### FR-2: Configuration File Structure
- Global config **MUST** support identical structure to `.taskmaster/config.json`:
  ```json
  {
    "models": {
      "main": { "provider": "...", "modelId": "...", "maxTokens": ..., "temperature": ... },
      "research": { ... },
      "fallback": { ... }
    },
    "global": { "logLevel": "...", "debug": false, ... },
    "claudeCode": { ... },
    "codexCli": { ... },
    "grokCli": { ... },
    "providers": { ... }  // NEW: Custom provider definitions
  }
  ```

#### FR-3: Configuration Merge Strategy
- **Precedence Order** (highest to lowest):
  1. Project-local config (`.taskmaster/config.json`)
  2. Global config (`$XDG_CONFIG_HOME/taskmaster/config.json`)
  3. Default config (hardcoded in `config-manager.js`)

- **Atomic Merge for Models**:
  - If local defines `models.main`, use entire local `models.main` object
  - If local does NOT define `models.main`, use global `models.main`
  - Same logic for `models.research` and `models.fallback`
  - **DO NOT** deep merge individual fields within model configs

- **Deep Merge for Other Sections**:
  - `global.*`: Deep merge (local overrides specific fields)
  - `claudeCode.*`: Deep merge
  - `codexCli.*`: Deep merge
  - `grokCli.*`: Deep merge
  - `providers.*`: Deep merge (allow adding/overriding providers)

#### FR-4: Environment Variable Resolution
- **MUST** support global `.env` file at `$XDG_CONFIG_HOME/taskmaster/.env`
- **Precedence** for env vars (highest to lowest):
  1. `session.env` (MCP context)
  2. Project-local `.env` file
  3. Global `.env` file (**NEW**)
  4. `process.env` (system environment)

#### FR-5: Custom Provider Support
- Global config **MAY** define custom providers in `providers` section:
  ```json
  {
    "providers": {
      "my-custom-provider": {
        "name": "my-custom-provider",
        "displayName": "My Custom AI",
        "baseUrl": "https://api.custom.ai/v1",
        "apiKeyEnvVar": "MY_CUSTOM_API_KEY",
        "enabled": true
      }
    }
  }
  ```
- Custom providers **MUST** be validated against base interface
- Project-local configs **MAY** override or disable global providers

#### FR-6: CLI Commands
- `task-master config --global`: Show global configuration
- `task-master config --global --set models.main.provider=<provider>`: Set global value
- `task-master config --global --path`: Display global config file path
- `task-master config --show-merged`: Show effective config for current project
- `task-master config --init-global`: Initialize global config with interactive prompts

#### FR-7: Backward Compatibility
- **MUST** continue working when no global config exists
- **MUST** support existing `.taskmaster/config.json` files without changes
- **MUST NOT** require migration of existing projects

### Non-Functional Requirements

#### NFR-1: Performance
- Config loading **SHOULD** complete in < 50ms
- Config file reads **MUST** be cached to avoid repeated I/O
- Config merge **MUST NOT** add noticeable latency to CLI commands

#### NFR-2: Security
- Global config files **SHOULD** have restricted permissions (600)
- API keys **SHOULD** be stored in global `.env`, not config.json
- Error messages **MUST NOT** leak config file contents or paths in production

#### NFR-3: Usability
- Error messages **MUST** clearly indicate which config file has issues
- Validation errors **MUST** show file path and line number (when possible)
- CLI output **SHOULD** indicate when global vs. local config is used

#### NFR-4: Maintainability
- Config loading logic **MUST** be centralized in `config-manager.js`
- Config merge logic **MUST** have comprehensive unit tests
- Config discovery **MUST** be documented in code comments

## Technical Architecture

### System Components

#### 1. Configuration Discovery Layer
**Location**: `scripts/modules/config-manager.js`

```javascript
// New functions to add:
function getGlobalConfigPath() {
  const xdgConfig = process.env.XDG_CONFIG_HOME;
  const homeDir = process.env.HOME || process.env.USERPROFILE;

  if (xdgConfig) {
    return path.join(xdgConfig, 'taskmaster', 'config.json');
  }
  return path.join(homeDir, '.config', 'taskmaster', 'config.json');
}

function getGlobalEnvPath() {
  const xdgConfig = process.env.XDG_CONFIG_HOME;
  const homeDir = process.env.HOME || process.env.USERPROFILE;

  if (xdgConfig) {
    return path.join(xdgConfig, 'taskmaster', '.env');
  }
  return path.join(homeDir, '.config', 'taskmaster', '.env');
}
```

#### 2. Configuration Merge Layer
**Location**: `scripts/modules/config-manager.js`

```javascript
function _loadAndValidateConfig(explicitRoot = null) {
  const defaults = DEFAULTS;

  // 1. Start with defaults
  let config = { ...defaults };

  // 2. Load and merge global config (if exists)
  const globalConfigPath = getGlobalConfigPath();
  if (fs.existsSync(globalConfigPath)) {
    const globalConfig = JSON.parse(fs.readFileSync(globalConfigPath, 'utf-8'));
    config = mergeConfigs(config, globalConfig, { atomicModels: true });
  }

  // 3. Load and merge project config (if exists)
  const projectConfigPath = findConfigPath(null, { projectRoot: explicitRoot });
  if (projectConfigPath) {
    const projectConfig = JSON.parse(fs.readFileSync(projectConfigPath, 'utf-8'));
    config = mergeConfigs(config, projectConfig, { atomicModels: true });
  }

  return config;
}

function mergeConfigs(base, override, options = {}) {
  const result = { ...base };

  for (const key in override) {
    // Atomic merge for models section
    if (key === 'models' && options.atomicModels) {
      result.models = { ...base.models };

      // Replace entire model config if defined in override
      if (override.models.main) {
        result.models.main = { ...override.models.main };
      }
      if (override.models.research) {
        result.models.research = { ...override.models.research };
      }
      if (override.models.fallback) {
        result.models.fallback = { ...override.models.fallback };
      }
    }
    // Deep merge for other sections
    else if (typeof override[key] === 'object' && !Array.isArray(override[key])) {
      result[key] = { ...base[key], ...override[key] };
    }
    // Direct override for primitives and arrays
    else {
      result[key] = override[key];
    }
  }

  return result;
}
```

#### 3. Environment Variable Resolution
**Location**: `scripts/modules/utils.js`

```javascript
function resolveEnvVariable(key, session = null, projectRoot = null) {
  // 1. Check session.env (MCP context)
  if (session?.env?.[key]) {
    return session.env[key];
  }

  // 2. Check project .env
  if (projectRoot) {
    const projectEnvPath = path.join(projectRoot, '.env');
    if (fs.existsSync(projectEnvPath)) {
      const parsedEnv = dotenv.parse(fs.readFileSync(projectEnvPath, 'utf-8'));
      if (parsedEnv?.[key]) {
        return parsedEnv[key];
      }
    }
  }

  // 3. Check global .env (NEW)
  const globalEnvPath = getGlobalEnvPath();
  if (fs.existsSync(globalEnvPath)) {
    const parsedEnv = dotenv.parse(fs.readFileSync(globalEnvPath, 'utf-8'));
    if (parsedEnv?.[key]) {
      return parsedEnv[key];
    }
  }

  // 4. Check process.env
  if (process.env[key]) {
    return process.env[key];
  }

  return undefined;
}
```

#### 4. CLI Command Implementation
**Location**: `scripts/modules/commands.js`

```javascript
// Add new command: task-master config
program
  .command('config')
  .description('Manage Task Master configuration')
  .option('--global', 'Operate on global config')
  .option('--show-merged', 'Show effective config for current project')
  .option('--path', 'Show config file path')
  .option('--init-global', 'Initialize global config interactively')
  .option('--set <key=value>', 'Set config value')
  .action(async (options) => {
    if (options.initGlobal) {
      await initializeGlobalConfig();
    } else if (options.path) {
      console.log(options.global ? getGlobalConfigPath() : findConfigPath());
    } else if (options.showMerged) {
      console.log(JSON.stringify(getConfig(), null, 2));
    } else if (options.set) {
      const [key, value] = options.set.split('=');
      await setConfigValue(key, value, options.global);
    } else {
      const config = options.global ? loadGlobalConfig() : getConfig();
      console.log(JSON.stringify(config, null, 2));
    }
  });
```

### Data Models

#### Global Configuration Schema
```typescript
interface GlobalConfig {
  models?: {
    main?: ModelConfig;
    research?: ModelConfig;
    fallback?: ModelConfig;
  };
  global?: GlobalSettings;
  providers?: Record<string, CustomProviderConfig>;
  claudeCode?: ClaudeCodeConfig;
  codexCli?: CodexCliConfig;
  grokCli?: GrokCliConfig;
}

interface CustomProviderConfig {
  name: string;
  displayName?: string;
  baseUrl?: string;
  apiKeyEnvVar?: string;
  enabled?: boolean;
}
```

### APIs and Integrations

#### MCP Tools (NEW)
```javascript
{
  name: "get_global_config",
  description: "Get global Task Master configuration",
  parameters: {},
  handler: async () => {
    return loadGlobalConfig();
  }
}

{
  name: "set_global_config_value",
  description: "Set a value in global configuration",
  parameters: {
    key: { type: "string", description: "Config key (dot notation)" },
    value: { type: "string", description: "Value to set" }
  },
  handler: async ({ key, value }) => {
    await setGlobalConfigValue(key, value);
  }
}
```

## Development Roadmap

### Phase 1: Core Global Config Support (MVP)
**Goal**: Load and merge global config with project config

**Deliverables**:
1. Implement `getGlobalConfigPath()` with XDG support
2. Implement `getGlobalEnvPath()` for global .env
3. Update `_loadAndValidateConfig()` to load global config
4. Implement `mergeConfigs()` with atomic model merge
5. Update `resolveEnvVariable()` to check global .env
6. Add unit tests for config discovery and merge logic
7. Add integration tests for full config loading flow

**Success Criteria**:
- Global config is loaded before project config
- Model configs are replaced atomically (not merged)
- Other sections are deep merged correctly
- All existing tests still pass

### Phase 2: CLI Commands
**Goal**: Provide user-facing commands to manage global config

**Deliverables**:
1. Implement `task-master config --global` command
2. Implement `task-master config --show-merged` command
3. Implement `task-master config --path` command
4. Implement `task-master config --set` command
5. Implement `task-master config --init-global` interactive setup
6. Add help text and examples for all commands
7. Add CLI integration tests

**Success Criteria**:
- Users can view global config
- Users can modify global config via CLI
- Users can see effective merged config
- Interactive init creates valid global config

### Phase 3: Custom Provider Support
**Goal**: Enable global custom provider definitions

**Deliverables**:
1. Add `providers` section to config schema
2. Implement provider validation for custom providers
3. Update `_getProvider()` to check global custom providers
4. Add CLI commands for provider management
5. Add documentation for custom provider format
6. Add examples for common custom providers (OpenRouter, etc.)

**Success Criteria**:
- Custom providers can be defined globally
- Custom providers work across all projects
- Provider validation prevents invalid configs

### Phase 4: MCP Integration
**Goal**: Expose global config via MCP tools

**Deliverables**:
1. Add `get_global_config` MCP tool
2. Add `set_global_config_value` MCP tool
3. Update existing MCP tools to respect global config
4. Add MCP integration tests
5. Update MCP documentation

**Success Criteria**:
- MCP clients can read global config
- MCP clients can modify global config
- All existing MCP tools work with global config

### Phase 5: Enhanced UX & Documentation
**Goal**: Improve discoverability and usability

**Deliverables**:
1. Add `task-master config --diff` to show global vs. local differences
2. Add config source indicators in CLI output
3. Improve error messages for config issues
4. Write comprehensive documentation
5. Add troubleshooting guide
6. Create video tutorial or walkthrough

**Success Criteria**:
- Users understand where config values come from
- Config errors are easy to diagnose
- Documentation covers all use cases

## Logical Dependency Chain

### Foundation (Must Be First)
1. **Config Discovery**: Implement XDG path resolution
   - Required by all subsequent phases
   - No dependencies on other features

2. **Config Loading**: Update `_loadAndValidateConfig()`
   - Depends on: Config discovery
   - Required by: Config merge, CLI commands

3. **Config Merge**: Implement atomic model merge
   - Depends on: Config loading
   - Required by: All features using config

### Core Functionality (Build Upon Foundation)
4. **Env Variable Resolution**: Global .env support
   - Depends on: Config discovery
   - Independent of config loading (parallel development)

5. **Validation**: Ensure global config is valid
   - Depends on: Config loading, Config merge
   - Required by: CLI commands, Custom providers

### User-Facing Features (Build on Core)
6. **Basic CLI Commands**: View and path commands
   - Depends on: Config loading, Config merge, Validation
   - Required by: Advanced CLI commands

7. **Write CLI Commands**: Set and init commands
   - Depends on: Basic CLI commands, Validation
   - Required by: Custom provider management

### Advanced Features (Final Layer)
8. **Custom Provider Support**: Global provider definitions
   - Depends on: Config merge, Validation, Write CLI commands
   - Independent of MCP integration

9. **MCP Integration**: Expose via MCP tools
   - Depends on: Config loading, Config merge, Validation
   - Independent of CLI commands (parallel development)

10. **Enhanced UX**: Diff, source indicators, better errors
    - Depends on: All core functionality
    - Final polish, not blocking other features

### Parallel Development Opportunities
- **Env variable resolution** can be developed in parallel with **Config merge**
- **CLI commands** can be developed in parallel with **MCP integration**
- **Custom provider support** can be developed in parallel with **MCP integration**

## Testing Strategy

### Unit Tests
1. **Config Discovery Tests** (`test/unit/config-discovery.test.js`)
   - Test XDG_CONFIG_HOME detection
   - Test fallback to ~/.config
   - Test Windows/macOS compatibility
   - Test directory creation

2. **Config Merge Tests** (`test/unit/config-merge.test.js`)
   - Test atomic model merge (main, research, fallback)
   - Test deep merge for global, claudeCode, etc.
   - Test precedence order (local > global > default)
   - Test empty/missing sections

3. **Env Resolution Tests** (`test/unit/env-resolution.test.js`)
   - Test global .env loading
   - Test precedence order
   - Test missing env files

4. **CLI Command Tests** (`test/unit/cli-config.test.js`)
   - Test all config command options
   - Test set/get operations
   - Test error handling

### Integration Tests
1. **Full Config Loading** (`test/integration/global-config.test.js`)
   - Create mock global and local configs
   - Verify merged result
   - Test with real file I/O

2. **End-to-End CLI** (`test/integration/cli-config-e2e.test.js`)
   - Test complete workflows (init, set, get)
   - Verify file modifications
   - Test error scenarios

3. **MCP Integration** (`test/integration/mcp-global-config.test.js`)
   - Test MCP tools with global config
   - Verify MCP session env precedence

### Manual Testing Scenarios
1. Fresh installation with no configs
2. Existing project with local config, adding global
3. Multiple projects using same global config
4. Override global model with local model
5. Custom provider in global config, used by project

## Risks and Mitigations

### Technical Challenges

**Risk**: Breaking existing configurations during merge
- **Mitigation**: Extensive unit tests, backward compatibility tests
- **Contingency**: Feature flag to disable global config

**Risk**: Performance degradation from multiple file reads
- **Mitigation**: Implement config caching, lazy loading
- **Contingency**: Profile and optimize hot paths

**Risk**: XDG specification edge cases on different platforms
- **Mitigation**: Test on Linux, macOS, Windows, WSL
- **Contingency**: Platform-specific fallback logic

### Scope Management

**Risk**: Feature creep (profiles, cloud sync, etc.)
- **Mitigation**: Clearly defined MVP scope, future enhancement list
- **Contingency**: Defer non-essential features to future releases

**Risk**: Complex merge logic causing subtle bugs
- **Mitigation**: Comprehensive test coverage, clear documentation
- **Contingency**: Simplify merge rules if too complex

### User Experience

**Risk**: Users confused about config precedence
- **Mitigation**: Clear CLI output showing config sources
- **Contingency**: Add `--explain` flag to show decision process

**Risk**: Migration pain for existing users
- **Mitigation**: Global config is optional, existing configs work unchanged
- **Contingency**: Provide migration tools/scripts

## Success Metrics

### Quantitative Metrics
- **Adoption Rate**: 30% of active users create global config within 1 month
- **Config Duplication**: 50% reduction in repeated config blocks across user projects
- **Support Tickets**: 25% reduction in config-related issues
- **Performance**: Config loading time < 50ms (including global)

### Qualitative Metrics
- **User Feedback**: Positive sentiment in GitHub issues/discussions
- **Documentation Quality**: < 5 clarification questions per 100 users
- **Developer Experience**: Contributors find config code easy to understand

## Appendix

### Research Findings

#### XDG Base Directory Specification
- Standard: https://specifications.freedesktop.org/basedir-spec/latest/
- `$XDG_CONFIG_HOME` defaults to `~/.config` if unset
- Config files should be at `$XDG_CONFIG_HOME/<application>/config.json`

#### Similar Implementations
- **Git**: Uses `~/.gitconfig` (pre-XDG), now supports `$XDG_CONFIG_HOME/git/config`
- **NPM**: Uses `~/.npmrc` globally, `.npmrc` locally
- **VS Code**: Uses `~/.config/Code/User/settings.json` on Linux
- **Neovim**: Uses `$XDG_CONFIG_HOME/nvim/init.lua`

### Technical Specifications

#### File Permissions
- Global config: `644` (readable by user, not writable by others)
- Global .env: `600` (readable/writable by user only)
- Global config directory: `755` (traversable by all)

#### Config Schema Version
Add `configVersion` field to detect future schema changes:
```json
{
  "configVersion": "2.0.0",
  "models": { ... }
}
```

#### Error Codes
- `CONFIG_GLOBAL_NOT_FOUND`: Global config expected but not found
- `CONFIG_GLOBAL_INVALID`: Global config exists but invalid JSON
- `CONFIG_MERGE_FAILED`: Error during config merge operation
- `CONFIG_PERMISSION_DENIED`: Cannot read/write global config file

### Example Configurations

#### Minimal Global Config
```json
{
  "models": {
    "main": {
      "provider": "anthropic",
      "modelId": "claude-sonnet-4-20250514",
      "maxTokens": 64000,
      "temperature": 0.2
    }
  }
}
```

#### Global Config with Custom Provider
```json
{
  "models": {
    "main": {
      "provider": "my-custom-provider",
      "modelId": "custom-model-v1",
      "maxTokens": 4096,
      "temperature": 0.7
    }
  },
  "providers": {
    "my-custom-provider": {
      "name": "my-custom-provider",
      "displayName": "My Custom AI",
      "baseUrl": "https://api.mycustom.ai/v1",
      "apiKeyEnvVar": "MY_CUSTOM_API_KEY",
      "enabled": true
    }
  },
  "global": {
    "logLevel": "debug"
  }
}
```

#### Global .env File
```bash
# API Keys for all projects
ANTHROPIC_API_KEY=sk-ant-...
OPENAI_API_KEY=sk-...
PERPLEXITY_API_KEY=pplx-...

# Custom provider
MY_CUSTOM_API_KEY=custom-...
```

### Migration Guide

#### For Existing Users
No migration required! Global config is optional. To start using:

```bash
# 1. Create global config directory
mkdir -p ~/.config/taskmaster

# 2. Copy your preferred project config as starting point
cp my-project/.taskmaster/config.json ~/.config/taskmaster/config.json

# 3. Edit to keep only settings you want globally
# Remove project-specific settings

# 4. (Optional) Move API keys to global .env
echo "ANTHROPIC_API_KEY=sk-..." > ~/.config/taskmaster/.env
```

#### For New Users
```bash
# Initialize global config interactively
task-master config --init-global

# Or create manually
mkdir -p ~/.config/taskmaster
cat > ~/.config/taskmaster/config.json << EOF
{
  "models": {
    "main": {
      "provider": "anthropic",
      "modelId": "claude-sonnet-4-20250514"
    }
  }
}
EOF
```
